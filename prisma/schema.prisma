 generator client {
   provider = "prisma-client-js"
 }

 datasource db {
   provider = "postgresql"
   url      = env("DATABASE_URL")
 }

 model User {
  id           String   @id @default(cuid())
  name         String?
  email        String? @unique
  image        String?
  // local auth
  passwordHash String?
  role         Role     @default(USER)
  guest        Boolean  @default(false)
  consentFlags Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  accounts     Account[]
  sessions     Session[]
  threads      Thread[]
  observations Observation[]
  alerts       Alert[]
}

enum Role {
  USER
  ADMIN
  GUEST
}

 model Account {
   id                String   @id @default(cuid())
   userId            String
   type              String
   provider          String
   providerAccountId String
   refresh_token     String?  @db.Text
   access_token      String?  @db.Text
   expires_at        Int?
   token_type        String?
   scope             String?
   id_token          String?  @db.Text
   session_state     String?
   user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
   @@unique([provider, providerAccountId])
 }

 model Session {
   id           String   @id @default(cuid())
   sessionToken String   @unique
   userId       String
   expires      DateTime
   user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
 }

 model VerificationToken {
   identifier String
   token      String   @unique
   expires    DateTime
   @@unique([identifier, token])
 }

 model Thread {
   id             String   @id @default(cuid())
   userId         String
   title          String?
   createdAt      DateTime @default(now())
   lastActivityAt DateTime @default(now())
   user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
   messages       Message[]
   predictions    Prediction[]
   alerts         Alert[]
   @@index([userId, lastActivityAt(sort: Desc)])
 }

model Message {
  id         String   @id @default(cuid())
  threadId   String
  senderType String
  text       String?
  createdAt  DateTime @default(now())
  thread     Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)
  attachments Attachment[]
  predictions Prediction[] @relation("PredictionInput")
  @@index([threadId, createdAt])
 }
 model Attachment {
   id        String   @id @default(cuid())
   messageId String
   url       String
   mime      String
   bytes     Int
   kind      String
   createdAt DateTime @default(now())
   message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
 }

 model Prediction {
   id             String   @id @default(cuid())
   threadId       String
   inputMessageId String?
   model          String
   riskScore      Int
   band           String
   factors        Json?
   recommendations Json?
   createdAt      DateTime @default(now())
   thread         Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)
   inputMessage   Message? @relation("PredictionInput", fields: [inputMessageId], references: [id])
   @@index([threadId, createdAt])
 }

 model Observation {
   id         String   @id @default(cuid())
   userId     String
   kind       String
   value      Json
   observedAt DateTime
   source     String
   user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
   @@index([userId, observedAt(sort: Desc)])
 }

 model Alert {
   id         String   @id @default(cuid())
   userId     String
   threadId   String?
   severity   String
   title      String
   body       String
   status     String   @default("open")
   createdAt  DateTime @default(now())
   resolvedAt DateTime?
   user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
   thread     Thread?  @relation(fields: [threadId], references: [id], onDelete: Cascade)
   @@index([userId, status, createdAt(sort: Desc)])
 }
